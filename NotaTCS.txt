### Plan Detallado Ajustado para el Reto Técnico Usando PostgreSQL y Docker Compose (Aplicando Buenas Prácticas SOLID)

Este plan está diseñado para cumplir con los requisitos del reto técnico, aplicando los **principios SOLID**, con **PostgreSQL** como base de datos para ambos microservicios y un despliegue completo en **Docker Compose** que orquestará los microservicios junto con PostgreSQL y RabbitMQ.

---

### **1. Configuración Inicial del Proyecto**

	#### 1.1. Crear los Microservicios con Spring Initializr
	Genera **dos microservicios** utilizando Spring Initializr:

	- **Microservicio 1:** `clientes_personas`
	  - **Group ID:** `com.tcs.microservices`
	  - **Artifact ID:** `clientes_personas`
	  - **Versión de Spring Boot:** 3.3.3
	  - **Dependencias:**
	    - Spring Web (para manejar solicitudes HTTP)
	    - Spring Data JPA (para interactuar con PostgreSQL)
	    - Lombok (para reducir código repetitivo en Java)
	    - PostgreSQL Driver (para conectarse a la base de datos)
	    - Spring Boot Actuator (para monitoreo y métricas)
	    - Spring for RabbitMQ (para comunicación asincrónica)
	    - DevTools (opcional para recarga automática durante el desarrollo)
	    - Swagger/OpenAPI (para la documentación de APIs)

	- **Microservicio 2:** `cuentas_movimientos`
	  - **Group ID:** `com.tcs.microservices`
	  - **Artifact ID:** `cuentas_movimientos`
	  - **Versión de Spring Boot:** 3.3.3
	  - **Dependencias:**
	    - Spring Web
	    - Spring Data JPA
	    - Lombok
	    - PostgreSQL Driver
	    - Spring Boot Actuator
	    - Spring for RabbitMQ
	    - DevTools
	    - Swagger/OpenAPI

	#### 1.2. Configuración en Visual Studio Code
	Configura tu entorno de desarrollo en Visual Studio Code con las siguientes extensiones:
	- **Extension Pack for Java**
	- **Lombok Support**
	- **Docker Extension** para manejar los contenedores de Docker

---

### **2. Configuración de Bases de Datos PostgreSQL**

	#### 2.1. Uso de Docker para PostgreSQL
	Para ambas bases de datos (`clientes_db` y `cuentas_db`), usaremos **PostgreSQL** como motor de base de datos. En el archivo `docker-compose.yml`, se definirán los servicios de PostgreSQL para ambos microservicios.

	Cada microservicio tendrá su propia base de datos PostgreSQL, una para `clientes_personas` y otra para `cuentas_movimientos`.

---

### **3. Script de Base de Datos PostgreSQL**

	#### 3.1. Microservicio `clientes_personas`
	**Base de Datos:** `clientes_db`

	Este microservicio manejará la información de **Personas** y **Clientes**, donde **Cliente** es una extensión de **Persona**. La base de datos `clientes_db` contendrá las tablas necesarias para estos datos.

	- **Tabla `persona`:** Almacena información básica como nombre, género, edad, identificación, dirección, y teléfono.
	- **Tabla `cliente`:** Extiende la tabla `persona` e incluye atributos como `cliente_id`, contraseña y estado del cliente.

	#### 3.2. Microservicio `cuentas_movimientos`
	**Base de Datos:** `cuentas_db`

	Este microservicio manejará la información de **Cuentas** y **Movimientos**.

	- **Tabla `cuenta`:** Almacena información de las cuentas, como número de cuenta, tipo de cuenta, saldo inicial, y el estado de la cuenta. Cada cuenta está asociada a un cliente.
	- **Tabla `movimiento`:** Almacena las transacciones realizadas en las cuentas, como depósitos y retiros. Cada movimiento tiene un valor y un saldo resultante.

---

### **4. Comunicación Asincrónica con RabbitMQ**

	#### 4.1. Configuración de RabbitMQ en Docker Compose
	El archivo `docker-compose.yml` debe contener la configuración de RabbitMQ como broker de mensajes, lo que permitirá la comunicación asincrónica entre los microservicios.

	#### 4.2. Publicar y Consumir Mensajes
	- **Microservicio `cuentas_movimientos`:** Publicará mensajes relacionados con los movimientos realizados en las cuentas.
	- **Microservicio `clientes_personas`:** Consumirá estos mensajes para registrar o actualizar la información de los clientes y movimientos asociados.

	Ambos microservicios deben tener configuraciones para enviar y recibir mensajes de las colas de RabbitMQ.

---

### **5. Implementación de Funcionalidades CRUD (F1)**

#### 5.1. CRUD en `clientes_personas`
En este microservicio, se implementarán los endpoints REST para manejar las operaciones CRUD de `Cliente` y `Persona`. Se usarán las siguientes operaciones:
- **POST /clientes:** Para crear un cliente.
- **GET /clientes/{id}:** Para obtener la información de un cliente específico.
- **PUT /clientes/{id}:** Para actualizar la información de un cliente.
- **DELETE /clientes/{id}:** Para eliminar un cliente.

#### 5.2. CRUD en `cuentas_movimientos`
En este microservicio, se implementarán los endpoints REST para manejar las operaciones CRUD de `Cuenta` y `Movimiento`. Se usarán las siguientes operaciones:
- **POST /cuentas:** Para crear una cuenta.
- **POST /movimientos:** Para registrar un movimiento en una cuenta (depósito/retiro).
- **GET /movimientos:** Para obtener el historial de movimientos.

---

### **6. Registro de Movimientos y Validación de Saldo (F2 y F3)**

#### 6.1. Registro de Movimientos
Al registrar un movimiento, se actualizará el saldo de la cuenta asociada. El saldo se ajustará de acuerdo con el tipo de movimiento (depósito o retiro).

#### 6.2. Validación de Saldo
Antes de realizar un retiro, se debe verificar si el saldo disponible es suficiente. Si no lo es, se lanzará una excepción con el mensaje "Saldo no disponible".

---

### **7. Generación de Reportes (F4)**

#### 7.1. Generación de Reportes
Implementa un endpoint en el microservicio `cuentas_movimientos` que permita generar reportes de movimientos de cuentas, filtrados por cliente y por rango de fechas.

#### 7.2. Reporte en Formato JSON
El reporte debe devolver un listado de cuentas con sus movimientos asociados, incluyendo información como fecha, tipo de movimiento, valor del movimiento y el saldo resultante.

---

### **8. Documentación de API con Swagger (F5)**

#### 8.1. Uso de Swagger
Utiliza **Swagger** para generar la documentación de las APIs en ambos microservicios. La documentación estará disponible en `/swagger-ui.html` y será exportable para Postman.

#### 8.2. Exportación a Postman
Una vez que la API esté documentada en Swagger, exporta la colección para usarla en **Postman** para realizar pruebas manuales.

---

### **9. Pruebas Unitarias y de Integración con JUnit y Mockito (F6)**

#### 9.1. Pruebas Unitarias
Utiliza **JUnit** y **Mockito** para escribir pruebas unitarias que validen el comportamiento de los servicios y controladores de cada microservicio. Prueba las operaciones CRUD y la lógica de negocio, como la validación de saldos y el registro de movimientos.

#### 9.2. Pruebas de Integración
Escribe pruebas de integración para asegurarte de que las APIs funcionan correctamente y se conectan con la base de datos PostgreSQL. Prueba la comunicación entre los microservicios usando RabbitMQ para asegurarte de que los mensajes se envían y reciben correctamente.

---

### **10. Despliegue Completo en Contenedores Docker (F7) - Continuación**

#### 10.2. Configuración del `docker-compose.yml` (Continuación)

El archivo `docker-compose.yml` debe incluir la configuración completa para orquestar los microservicios junto con PostgreSQL y RabbitMQ.

```yaml
version: "3"
services:
  postgres_clientes:
    image: postgres:14
    environment:
      POSTGRES_DB: clientes_db
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
    ports:
      - "5433:5432"
    container_name: postgres_clientes
    volumes:
      - ./db-init/clientes_personas.sql:/docker-entrypoint-initdb.d/clientes_personas.sql
    networks:
      - microservices-network
    restart: always

  postgres_cuentas:
    image: postgres:14
    environment:
      POSTGRES_DB: cuentas_db
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
    ports:
      - "5434:5432"
    container_name: postgres_cuentas
    volumes:
      - ./db-init/cuentas_movimientos.sql:/docker-entrypoint-initdb.d/cuentas_movimientos.sql
    networks:
      - microservices-network
    restart: always

  rabbitmq:
    image: rabbitmq:management
    ports:
      - "5672:5672"
      - "15672:15672"
    container_name: rabbitmq
    networks:
      - microservices-network
    restart: always

  clientes_personas:
    build: ./clientes_personas
    container_name: clientes-personas
    ports:
      - "8080:8080"
    depends_on:
      - postgres_clientes
      - rabbitmq
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres_clientes:5432/clientes_db
      SPRING_DATASOURCE_USERNAME: admin
      SPRING_DATASOURCE_PASSWORD: admin
      SPRING_RABBITMQ_HOST: rabbitmq
    networks:
      - microservices-network

  cuentas_movimientos:
    build: ./cuentas_movimientos
    container_name: cuentas-movimientos
    ports:
      - "8081:8081"
    depends_on:
      - postgres_cuentas
      - rabbitmq
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres_cuentas:5432/cuentas_db
      SPRING_DATASOURCE_USERNAME: admin
      SPRING_DATASOURCE_PASSWORD: admin
      SPRING_RABBITMQ_HOST: rabbitmq
    networks:
      - microservices-network

networks:
  microservices-network:
    driver: bridge
```

#### 10.3. Detalles Importantes del `docker-compose.yml`

1. **PostgreSQL para `clientes_personas`:** Configurado en el servicio `postgres_clientes`, escucha en el puerto `5432` y tiene como base de datos `clientes_db`. Se conecta al microservicio `clientes_personas` a través de la variable de entorno `SPRING_DATASOURCE_URL`.

2. **PostgreSQL para `cuentas_movimientos`:** Configurado en el servicio `postgres_cuentas`, escucha en el puerto `5433` y tiene como base de datos `cuentas_db`. El microservicio `cuentas_movimientos` se conecta a través de la variable `SPRING_DATASOURCE_URL`.

3. **RabbitMQ:** Configurado como servicio de mensajería, expone los puertos `5672` para la comunicación con los microservicios y `15672` para la interfaz de gestión accesible desde `http://localhost:15672`. Ambos microservicios se conectan usando la variable `SPRING_RABBITMQ_HOST`.

4. **Microservicios (`clientes_personas` y `cuentas_movimientos`):** Cada uno de los microservicios se configura con los detalles de su base de datos y RabbitMQ mediante variables de entorno. Ambos están configurados para depender de los servicios de PostgreSQL y RabbitMQ, lo que garantiza que no se inicien hasta que esos servicios estén listos.

5. **Red de Contenedores:** Todos los servicios están en la misma red `microservices-network` para que puedan comunicarse entre sí usando sus nombres de servicio como hostname (`postgres_clientes`, `postgres_cuentas`, `rabbitmq`).

---

### **11. Validación Final y Despliegue**

#### 11.1. Iniciar los Contenedores con Docker Compose

Para iniciar todos los contenedores definidos en el archivo `docker-compose.yml`, ejecuta el siguiente comando desde el directorio que contiene el archivo:

```bash
docker-compose up --build
```

Este comando:
- Construirá los microservicios `clientes_personas` y `cuentas_movimientos`.
- Levantará los servicios de PostgreSQL (`clientes_db` y `cuentas_db`).
- Levantará RabbitMQ para la comunicación entre microservicios.

#### 11.2. Validar la Conectividad y Funcionalidad

1. **Verificar RabbitMQ:** Accede al panel de control de RabbitMQ en `http://localhost:15672` (usuario/contraseña: `guest`/`guest`) para asegurarte de que las colas y los exchanges se están creando correctamente.
   
2. **Probar los Endpoints de los Microservicios:** Usa **Swagger UI** disponible en `http://localhost:8080/swagger-ui.html` para `clientes_personas` y en `http://localhost:8081/swagger-ui.html` para `cuentas_movimientos` para validar que los endpoints funcionan correctamente.

3. **Validar la Base de Datos:** Conecta a PostgreSQL en `localhost:5432` (para `clientes_db`) y en `localhost:5433` (para `cuentas_db`) usando una herramienta como **pgAdmin** o un cliente de PostgreSQL para verificar que las tablas se crean y que los datos se insertan correctamente.

---

### **12. Generación de Documentación de API y Pruebas con Postman**

#### 12.1. Exportar Documentación con Swagger

- Utiliza **Swagger** en ambos microservicios para generar la documentación de la API. Desde la interfaz de Swagger (`/swagger-ui.html`), puedes exportar la documentación como una colección de **Postman**.

- Realiza las pruebas manuales de los endpoints utilizando Postman para confirmar que las operaciones CRUD y los movimientos de cuenta están funcionando como se espera.

#### 12.2. Realizar Pruebas Unitarias e Integración

- Realiza pruebas unitarias con **JUnit** y **Mockito** para verificar la lógica de negocio en cada microservicio. Las pruebas unitarias deben validar los CRUDs de clientes, cuentas y movimientos, así como la lógica para el manejo de saldos y movimientos.

- Realiza pruebas de integración para asegurarte de que los microservicios funcionan correctamente con PostgreSQL y RabbitMQ. Las pruebas deben incluir el flujo completo de interacción entre microservicios, verificando que los mensajes se envían y reciben correctamente a través de RabbitMQ.

---

### **13. Entrega Final**

1. **Sube el proyecto a un repositorio Git público** (e.g., GitHub) para que sea accesible.

2. **Incluye instrucciones claras** en el archivo `README.md` del repositorio, explicando cómo clonar el repositorio, cómo levantar el entorno con Docker, y cómo ejecutar las pruebas.

3. **Documentación:** Incluye la exportación de las pruebas realizadas en Postman para validar los endpoints.

---

### **14. Aplicación de Principios SOLID y Buenas Prácticas**

Este plan se basa en principios SOLID y buenas prácticas para cada capa del proyecto:

#### 14.1. **Capa de Modelo (Entidades)**

- **Encapsulamiento y JavaBeans/POJOs:** Las entidades de dominio deben tener atributos privados, getters/setters y constructores.
- **Anotaciones JPA:** Usa `@Entity` y `@Table` para mapear las clases con las tablas de PostgreSQL. Define relaciones como `@OneToMany` entre Cliente y Cuenta, y entre Cuenta y Movimiento.
- **Validación:** Usa anotaciones como `@NotNull`, `@NotBlank`, y `@PositiveOrZero` para validar atributos.
- **DTOs:** Usa DTOs para transferencia de datos, protegiendo la integridad del modelo.

#### 14.2. **Capa de Repositorio**

- **Extensión de `JpaRepository`:** Los repositorios deben implementar consultas personalizadas usando métodos derivados como `findByCuentaAndFechaBetween`.
- **Transacciones con `@Transactional`:** Asegura que las operaciones críticas, como el registro de movimientos y la actualización de saldos, se realicen de manera atómica.

#### 14.3. **Capa de Servicio**

- **Responsabilidad Única (SRP):** Cada servicio (ClienteService, CuentaService, MovimientosService) tiene su propia responsabilidad, como gestionar clientes o cuentas.
- **Delegación a Repositorios:** Los servicios delegan toda la lógica de persistencia a los repositorios, manteniendo la lógica de negocio separada.
- **Manejo de Excepciones:** Usa excepciones claras para manejar errores, como `SaldoInsuficienteException`.

#### 14.4. **Capa de Controlador**

- **Controladores Delgados:** Los controladores son responsables de manejar las solicitudes HTTP y delegar la lógica de negocio a los servicios.
- **Validación de Datos con `@Valid`:** Valida los datos de entrada en las solicitudes, como la creación de clientes o cuentas.
- **Manejo Global de Excepciones:** Usa `@ControllerAdvice` para manejar excepciones globalmente y devolver respuestas HTTP adecuadas.

---

Este plan ajustado ofrece una guía completa para implementar la solución del reto técnico, garantizando una 
arquitectura sólida, escalable y fácil de mantener.