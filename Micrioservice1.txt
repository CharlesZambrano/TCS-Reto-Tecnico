MICROSERVICIO 1:
	
	build.gradle:
	
		plugins {
			id 'java'
			id 'org.springframework.boot' version '3.3.3'
			id 'io.spring.dependency-management' version '1.1.6'
			id "io.freefair.lombok" version "8.6"
		}

		group = 'com.tcs.microservices'
		version = 'V1'

		java {
			toolchain {
				languageVersion = JavaLanguageVersion.of(21)
			}
		}

		configurations {
			compileOnly {
				extendsFrom annotationProcessor
			}
		}

		repositories {
			mavenCentral()
		}

		dependencies {
			// Dependencias de Spring Boot
			implementation 'org.springframework.boot:spring-boot-starter-actuator'
			implementation 'org.springframework.boot:spring-boot-starter-amqp'
			implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
			implementation 'org.springframework.boot:spring-boot-starter-web'
			implementation 'org.springframework.boot:spring-boot-starter-validation'

			// Hibernate Validator
			implementation 'org.hibernate.validator:hibernate-validator:8.0.0.Final'
			
		    // MapStruct
		    implementation 'org.mapstruct:mapstruct:1.5.5.Final'
		    annotationProcessor 'org.mapstruct:mapstruct-processor:1.5.5.Final'

		    // Lombok
		    compileOnly 'org.projectlombok:lombok'
		    annotationProcessor 'org.projectlombok:lombok'

			// Swagger dependencies
			implementation 'io.springfox:springfox-boot-starter:3.0.0'

			// Driver para PostgreSQL
			runtimeOnly 'org.postgresql:postgresql'

			// Jakarta Servlet API
			implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0'

			// Herramientas para el desarrollo
			developmentOnly 'org.springframework.boot:spring-boot-devtools'

			// Dependencias para Testing
			testImplementation 'org.springframework.boot:spring-boot-starter-test'
			testImplementation 'org.springframework.amqp:spring-rabbit-test'
			testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
		}

		tasks.named('test') {
			useJUnitPlatform()
		}

	application.properties:

		spring.application.name=clientes_personas

		# Configuración de la base de datos PostgreSQL
		spring.datasource.url=jdbc:postgresql://localhost:5433/clientes_db
		spring.datasource.username=admin
		spring.datasource.password=admin

		# Configuración de Hibernate
		spring.datasource.driver-class-name=org.postgresql.Driver
		spring.jpa.hibernate.ddl-auto=none
		spring.jpa.show-sql=true
		spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

		# Nivel de logging
		logging.level.org.springframework.web=DEBUG
		logging.level.org.hibernate.SQL=DEBUG
		logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

		# Configuración de RabbitMQ
		spring.rabbitmq.host=rabbitmq
		spring.rabbitmq.port=5672
		spring.rabbitmq.username=guest
		spring.rabbitmq.password=guest

	Script base de datos:

		CREATE TABLE IF NOT EXISTS persona (
		    persona_id SERIAL PRIMARY KEY,
		    nombre VARCHAR(100) NOT NULL,
		    genero VARCHAR(3) CHECK (genero IN ('MAS', 'FEM', 'OTR')),
		    edad INT,
		    identificacion VARCHAR(20) UNIQUE NOT NULL,
		    direccion VARCHAR(255),
		    telefono VARCHAR(15)
		);

		COMMENT ON TABLE persona IS 'Tabla que almacena los datos de una persona, incluyendo su género, identificación y datos de contacto';

		COMMENT ON COLUMN persona.persona_id IS 'Clave primaria única para cada persona';
		COMMENT ON COLUMN persona.nombre IS 'Nombre completo de la persona';
		COMMENT ON COLUMN persona.genero IS 'Género de la persona: MAS = Masculino, FEM = Femenino, OTR = Otro';
		COMMENT ON COLUMN persona.edad IS 'Edad de la persona';
		COMMENT ON COLUMN persona.identificacion IS 'Identificación única de la persona';
		COMMENT ON COLUMN persona.direccion IS 'Dirección de la residencia de la persona';
		COMMENT ON COLUMN persona.telefono IS 'Número de teléfono de contacto';

		CREATE TABLE IF NOT EXISTS cliente (
		    cliente_id SERIAL PRIMARY KEY,
		    persona_id INT REFERENCES persona(persona_id),
		    contraseña VARCHAR(100) NOT NULL,
		    estado BOOLEAN NOT NULL,
		    UNIQUE (persona_id)
		);

		COMMENT ON TABLE cliente IS 'Tabla que almacena los datos de clientes vinculados a personas registradas en la tabla persona';

		COMMENT ON COLUMN cliente.cliente_id IS 'Clave primaria única para cada cliente';
		COMMENT ON COLUMN cliente.persona_id IS 'Referencia a la clave primaria de la tabla persona';
		COMMENT ON COLUMN cliente.contraseña IS 'Contraseña de acceso del cliente';
		COMMENT ON COLUMN cliente.estado IS 'Estado del cliente: activo o inactivo';

		CREATE INDEX IF NOT EXISTS idx_persona_identificacion ON persona (identificacion);
		CREATE INDEX IF NOT EXISTS idx_cliente_persona_id ON cliente (persona_id);

	Clase principal:

		package com.tcs.microservices.clientes_personas;

		import org.springframework.boot.SpringApplication;
		import org.springframework.boot.autoconfigure.SpringBootApplication;

		@SpringBootApplication
		public class ClientesPersonasApplication {

			public static void main(String[] args) {
				SpringApplication.run(ClientesPersonasApplication.class, args);
			}

		}

	Models:

		Cliente:

			package com.tcs.microservices.clientes_personas.model;

			import java.io.Serializable;

			import jakarta.persistence.CascadeType;
			import jakarta.persistence.Column;
			import jakarta.persistence.Entity;
			import jakarta.persistence.GeneratedValue;
			import jakarta.persistence.GenerationType;
			import jakarta.persistence.Id;
			import jakarta.persistence.JoinColumn;
			import jakarta.persistence.OneToOne;
			import jakarta.persistence.Table;
			import jakarta.validation.constraints.NotBlank;
			import jakarta.validation.constraints.Size;
			import lombok.AllArgsConstructor;
			import lombok.EqualsAndHashCode;
			import lombok.Getter;
			import lombok.NoArgsConstructor;
			import lombok.Setter;
			import lombok.ToString;

			@ToString
			@EqualsAndHashCode
			@Getter
			@Setter
			@AllArgsConstructor
			@NoArgsConstructor
			@Entity
			@Table(name = "cliente")
			public class Cliente implements Serializable {

			    private static final long serialVersionUID = 1L;

			    @Id
			    @GeneratedValue(strategy = GenerationType.IDENTITY)
			    @Column(name = "cliente_id")
			    private Long id;

			    @OneToOne(cascade = CascadeType.ALL)
			    @JoinColumn(name = "persona_id", referencedColumnName = "persona_id", unique = true)
			    private Persona persona;

			    @NotBlank(message = "La contraseña no puede estar vacía")
			    @Size(min = 8, max = 100)
			    @Column(name = "contraseña", nullable = false)
			    private String contraseña;

			    @Column(name = "estado", nullable = false)
			    private Boolean estado;
			}

		Persona:

			package com.tcs.microservices.clientes_personas.model;

			import java.io.Serializable;

			import jakarta.persistence.Column;
			import jakarta.persistence.Entity;
			import jakarta.persistence.GeneratedValue;
			import jakarta.persistence.GenerationType;
			import jakarta.persistence.Id;
			import jakarta.persistence.Table;
			import jakarta.validation.constraints.NotBlank;
			import jakarta.validation.constraints.Size;
			import lombok.AllArgsConstructor;
			import lombok.EqualsAndHashCode;
			import lombok.Getter;
			import lombok.NoArgsConstructor;
			import lombok.Setter;
			import lombok.ToString;

			@ToString
			@EqualsAndHashCode
			@Getter
			@Setter
			@AllArgsConstructor
			@NoArgsConstructor
			@Entity
			@Table(name = "persona")
			public class Persona implements Serializable {

			    private static final long serialVersionUID = 1L;

			    @Id
			    @GeneratedValue(strategy = GenerationType.IDENTITY)
			    @Column(name = "persona_id")
			    private Long id;

			    @NotBlank(message = "El nombre no puede estar vacío")
			    @Size(max = 100)
			    @Column(name = "nombre", nullable = false)
			    private String nombre;

			    @Size(max = 3)
			    @Column(name = "genero")
			    private String genero;

			    @Column(name = "edad")
			    private Integer edad;

			    @NotBlank(message = "La identificación no puede estar vacía")
			    @Size(max = 20)
			    @Column(name = "identificacion", nullable = false, unique = true)
			    private String identificacion;

			    @Size(max = 255)
			    @Column(name = "direccion")
			    private String direccion;

			    @Size(max = 15)
			    @Column(name = "telefono")
			    private String telefono;
			}

	DTO:

		ClienteDTO:

			package com.tcs.microservices.clientes_personas.dto;

			import jakarta.validation.constraints.NotBlank;
			import jakarta.validation.constraints.NotNull;
			import jakarta.validation.constraints.Size;
			import lombok.Builder;
			import lombok.Getter;
			import lombok.Setter;

			@Getter
			@Setter
			@Builder
			public class ClienteDTO {

			    private Long id;

			    @NotBlank(message = "La contraseña no puede estar vacía")
			    @Size(min = 8, max = 100, message = "La contraseña debe tener entre 8 y 100 caracteres")
			    private String contraseña;

			    @NotNull(message = "El estado no puede estar vacío")
			    private Boolean estado;

			    @NotNull(message = "La persona no puede estar vacía")
			    private PersonaDTO persona;
			}

		PersonaDTO:

			package com.tcs.microservices.clientes_personas.dto;

			import jakarta.validation.constraints.NotBlank;
			import jakarta.validation.constraints.Size;
			import lombok.Builder;
			import lombok.Getter;
			import lombok.Setter;

			@Getter
			@Setter
			@Builder
			public class PersonaDTO {

			    private Long id;

			    @NotBlank(message = "El nombre no puede estar vacío")
			    @Size(max = 100, message = "El nombre no puede tener más de 100 caracteres")
			    private String nombre;

			    @Size(max = 10, message = "El género no puede tener más de 10 caracteres")
			    private String genero;

			    private Integer edad;

			    @NotBlank(message = "La identificación no puede estar vacía")
			    @Size(max = 20, message = "La identificación no puede tener más de 20 caracteres")
			    private String identificacion;

			    @Size(max = 255, message = "La dirección no puede tener más de 255 caracteres")
			    private String direccion;

			    @Size(max = 15, message = "El teléfono no puede tener más de 15 caracteres")
			    private String telefono;
			}

	Repository:

		ClienteRepository:

			package com.tcs.microservices.clientes_personas.repository;

			import org.springframework.data.jpa.repository.JpaRepository;
			import org.springframework.stereotype.Repository;

			import com.tcs.microservices.clientes_personas.model.Cliente;

			@Repository
			public interface ClienteRepository extends JpaRepository<Cliente, Long> {
			}




		PersonaRepository:

			package com.tcs.microservices.clientes_personas.repository;

			import org.springframework.data.jpa.repository.JpaRepository;
			import org.springframework.stereotype.Repository;

			import com.tcs.microservices.clientes_personas.model.Persona;

			@Repository
			public interface PersonaRepository extends JpaRepository<Persona, Long> {
			}

	Service:

		ClienteService:

			package com.tcs.microservices.clientes_personas.service;

			import java.util.List;
			import java.util.stream.Collectors;

			import org.springframework.stereotype.Service;
			import org.springframework.transaction.annotation.Transactional;

			import com.tcs.microservices.clientes_personas.dto.ClienteDTO;
			import com.tcs.microservices.clientes_personas.model.Cliente;
			import com.tcs.microservices.clientes_personas.repository.ClienteRepository;
			import com.tcs.microservices.clientes_personas.util.mapper.ClientePersonaMapper;

			import jakarta.persistence.EntityNotFoundException;

			@Service
			public class ClienteService {

			    private final ClienteRepository clienteRepository;
			    private final ClientePersonaMapper clientePersonaMapper;
			    private final ClientePublisher clientePublisher;

			    public ClienteService(ClienteRepository clienteRepository, ClientePersonaMapper clientePersonaMapper,
			            ClientePublisher clientePublisher) {
			        this.clienteRepository = clienteRepository;
			        this.clientePersonaMapper = clientePersonaMapper;
			        this.clientePublisher = clientePublisher;
			    }

			    @Transactional(readOnly = true)
			    public List<ClienteDTO> obtenerClientes() {
			        return clienteRepository.findAll()
			                .stream()
			                .map(clientePersonaMapper::clienteToClienteDTO)
			                .collect(Collectors.toList());
			    }

			    @Transactional(readOnly = true)
			    public ClienteDTO obtenerClientePorId(Long id) {
			        Cliente cliente = clienteRepository.findById(id)
			                .orElseThrow(() -> new EntityNotFoundException("Cliente no encontrado"));
			        return clientePersonaMapper.clienteToClienteDTO(cliente);
			    }

			    @Transactional
			    public ClienteDTO crearCliente(ClienteDTO clienteDTO) {
			        Cliente cliente = clientePersonaMapper.clienteDTOToCliente(clienteDTO);
			        cliente = clienteRepository.save(cliente);

			        String mensaje = "Cliente creado con ID: " + cliente.getId();
			        clientePublisher.publishClienteCreado(mensaje);

			        return clientePersonaMapper.clienteToClienteDTO(cliente);
			    }

			    @Transactional
			    public ClienteDTO actualizarCliente(Long id, ClienteDTO clienteDTO) {
			        Cliente clienteExistente = clienteRepository.findById(id)
			                .orElseThrow(() -> new EntityNotFoundException("Cliente no encontrado"));

			        clientePersonaMapper.clienteDTOToCliente(clienteDTO);
			        clienteExistente.setContraseña(clienteDTO.getContraseña());
			        clienteExistente.setEstado(clienteDTO.getEstado());
			        clienteExistente.getPersona().setNombre(clienteDTO.getPersona().getNombre());
			        clienteRepository.save(clienteExistente);

			        String mensaje = "Cliente actualizado con ID: " + clienteExistente.getId();
			        clientePublisher.publishClienteActualizado(mensaje);

			        return clientePersonaMapper.clienteToClienteDTO(clienteExistente);
			    }

			    @Transactional
			    public void eliminarCliente(Long id) {
			        Cliente cliente = clienteRepository.findById(id)
			                .orElseThrow(() -> new EntityNotFoundException("Cliente no encontrado"));

			        clienteRepository.delete(cliente);

			        String mensaje = "Cliente eliminado con ID: " + cliente.getId();
			        clientePublisher.publishClienteEliminado(mensaje);
			    }
			}
		
		MovimientoConsumer:

			package com.tcs.microservices.clientes_personas.service;

			import org.springframework.amqp.rabbit.annotation.RabbitListener;
			import org.springframework.stereotype.Service;

			import com.tcs.microservices.clientes_personas.config.RabbitMQConfig;

			@Service
			public class MovimientoConsumer {

			    @RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)
			    public void recibirMensaje(String mensaje) {
			        System.out.println("Mensaje recibido: " + mensaje);
			        // Aquí puedes agregar la lógica para procesar el mensaje, por ejemplo,
			        // actualizar datos de clientes
			    }
			}


		ClientePublisher:

			package com.tcs.microservices.clientes_personas.service;

			import org.springframework.amqp.rabbit.core.RabbitTemplate;
			import org.springframework.stereotype.Service;

			import com.tcs.microservices.clientes_personas.config.RabbitMQConfig;

			@Service
			public class ClientePublisher {

			    private final RabbitTemplate rabbitTemplate;

			    public ClientePublisher(RabbitTemplate rabbitTemplate) {
			        this.rabbitTemplate = rabbitTemplate;
			    }

			    public void publishClienteCreado(String mensaje) {
			        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, RabbitMQConfig.ROUTING_KEY, mensaje);
			    }

			    public void publishClienteActualizado(String mensaje) {
			        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, RabbitMQConfig.ROUTING_KEY, mensaje);
			    }

			    public void publishClienteEliminado(String mensaje) {
			        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, RabbitMQConfig.ROUTING_KEY, mensaje);
			    }
			}

	Controller:

		ClienteController:

			package com.tcs.microservices.clientes_personas.controller;

			import java.util.List;

			import org.springframework.http.HttpStatus;
			import org.springframework.http.ResponseEntity;
			import org.springframework.validation.annotation.Validated;
			import org.springframework.web.bind.annotation.CrossOrigin;
			import org.springframework.web.bind.annotation.DeleteMapping;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.PathVariable;
			import org.springframework.web.bind.annotation.PostMapping;
			import org.springframework.web.bind.annotation.PutMapping;
			import org.springframework.web.bind.annotation.RequestBody;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RequestMethod;
			import org.springframework.web.bind.annotation.RestController;

			import com.tcs.microservices.clientes_personas.dto.ClienteDTO;
			import com.tcs.microservices.clientes_personas.service.ClienteService;

			import io.swagger.annotations.Api;
			import io.swagger.annotations.ApiOperation;

			@Api(value = "ClienteController", tags = { "Clientes" })
			@CrossOrigin(origins = "*", allowedHeaders = "*", methods = { RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT,
			        RequestMethod.DELETE })
			@RestController
			@RequestMapping("/api/v1/clientes")
			public class ClienteController {

			    private final ClienteService clienteService;

			    public ClienteController(ClienteService clienteService) {
			        this.clienteService = clienteService;
			    }

			    @ApiOperation(value = "Obtener todos los clientes")
			    @GetMapping
			    public ResponseEntity<List<ClienteDTO>> obtenerClientes() {
			        List<ClienteDTO> clientes = clienteService.obtenerClientes();
			        return ResponseEntity.ok(clientes);
			    }

			    @ApiOperation(value = "Obtener cliente por ID")
			    @GetMapping("/{id}")
			    public ResponseEntity<ClienteDTO> obtenerClientePorId(@PathVariable Long id) {
			        ClienteDTO cliente = clienteService.obtenerClientePorId(id);
			        return ResponseEntity.ok(cliente);
			    }

			    @ApiOperation(value = "Crear un nuevo cliente")
			    @PostMapping
			    public ResponseEntity<ClienteDTO> crearCliente(@Validated @RequestBody ClienteDTO clienteDTO) {
			        ClienteDTO nuevoCliente = clienteService.crearCliente(clienteDTO);
			        return new ResponseEntity<>(nuevoCliente, HttpStatus.CREATED);
			    }

			    @ApiOperation(value = "Actualizar un cliente")
			    @PutMapping("/{id}")
			    public ResponseEntity<ClienteDTO> actualizarCliente(@PathVariable Long id,
			            @Validated @RequestBody ClienteDTO clienteDTO) {
			        ClienteDTO clienteActualizado = clienteService.actualizarCliente(id, clienteDTO);
			        return ResponseEntity.ok(clienteActualizado);
			    }

			    @ApiOperation(value = "Eliminar un cliente")
			    @DeleteMapping("/{id}")
			    public ResponseEntity<Void> eliminarCliente(@PathVariable Long id) {
			        clienteService.eliminarCliente(id);
			        return ResponseEntity.noContent().build();
			    }
			}

	Config:

		RabbitMQConfig:

			package com.tcs.microservices.clientes_personas.config;

			import org.springframework.amqp.core.Binding;
			import org.springframework.amqp.core.BindingBuilder;
			import org.springframework.amqp.core.DirectExchange;
			import org.springframework.amqp.core.Queue;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;

			@Configuration
			public class RabbitMQConfig {

			    public static final String EXCHANGE_NAME = "clientes_exchange";
			    public static final String QUEUE_NAME = "clientes_queue";
			    public static final String ROUTING_KEY = "clientes_routingKey";

			    @Bean
			    public DirectExchange directExchange() {
			        return new DirectExchange(EXCHANGE_NAME);
			    }

			    @Bean
			    public Queue queue() {
			        return new Queue(QUEUE_NAME);
			    }

			    @Bean
			    public Binding binding(Queue queue, DirectExchange exchange) {
			        return BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);
			    }
			}

		SwaggerConfig:

			package com.tcs.microservices.clientes_personas.config;

			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;

			import springfox.documentation.builders.PathSelectors;
			import springfox.documentation.builders.RequestHandlerSelectors;
			import springfox.documentation.spi.DocumentationType;
			import springfox.documentation.spring.web.plugins.Docket;
			import springfox.documentation.swagger2.annotations.EnableSwagger2;

			@Configuration
			@EnableSwagger2
			public class SwaggerConfig {
			    @Bean
			    public Docket api() {
			        return new Docket(DocumentationType.SWAGGER_2)
			                .select()
			                .apis(RequestHandlerSelectors.basePackage("com.tcs.microservices"))
			                .paths(PathSelectors.any())
			                .build();
			    }
			}

	Util:

		package com.tcs.microservices.clientes_personas.util.mapper;

		import java.util.Random;

		import org.springframework.stereotype.Component;

		@Component
		public class UniqueIdGeneration {
		    public String generateUniqueId() {
		        String letters = generateRandomLetters(3);
		        String numbers = generateRandomNumbers(5);
		        String rawId = letters + "00" + numbers;
		        return rawId;
		    }

		    private String generateRandomLetters(int length) {
		        Random random = new Random();
		        StringBuilder sb = new StringBuilder(length);
		        for (int i = 0; i < length; i++) {
		            char letter = (char) ('A' + random.nextInt(26));
		            sb.append(letter);
		        }
		        return sb.toString();
		    }

		    private String generateRandomNumbers(int length) {
		        Random random = new Random();
		        StringBuilder sb = new StringBuilder(length);
		        for (int i = 0; i < length; i++) {
		            int number = random.nextInt(10);
		            sb.append(number);
		        }
		        return sb.toString();
		    }

		    public String getUniqueId() {
		        return generateUniqueId();
		    }
		}

	Mappers:

		package com.tcs.microservices.clientes_personas.util.mapper;

		import org.mapstruct.Mapper;
		import org.mapstruct.factory.Mappers;

		import com.tcs.microservices.clientes_personas.dto.ClienteDTO;
		import com.tcs.microservices.clientes_personas.dto.PersonaDTO;
		import com.tcs.microservices.clientes_personas.model.Cliente;
		import com.tcs.microservices.clientes_personas.model.Persona;

		@Mapper(componentModel = "spring")
		public interface ClientePersonaMapper {
		    ClientePersonaMapper INSTANCE = Mappers.getMapper(ClientePersonaMapper.class);

		    ClienteDTO clienteToClienteDTO(Cliente cliente);

		    Cliente clienteDTOToCliente(ClienteDTO clienteDTO);

		    PersonaDTO personaToPersonaDTO(Persona persona);

		    Persona personaDTOToPersona(PersonaDTO personaDTO);
		}

